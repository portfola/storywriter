#!/bin/bash

# AWS Frontend Resource Discovery Script
# Discovers existing AWS resources for storywriter frontend infrastructure
# Outputs terraform.tfvars and import commands

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd)"
PROJECT_NAME="storywriter"
DOMAINS=("staging.storywriter.net" "storywriter.net")
S3_PATTERN="${PROJECT_NAME}-*-frontend"
OUTPUT_DIR="${SCRIPT_DIR}/../terraform"
TFVARS_FILE="${OUTPUT_DIR}/discovered.tfvars"
IMPORT_FILE="${OUTPUT_DIR}/import-commands.sh"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Options
DRY_RUN=true
VERBOSE=false
REGION="us-east-1"

# Usage function
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Discover existing AWS frontend resources for storywriter project.
Runs in dry-run mode by default (no file writes).

OPTIONS:
    --real-run          Write files (terraform.tfvars and import commands)
    -v, --verbose       Enable verbose output
    -r, --region        AWS region (default: us-east-1)
    -h, --help          Show this help message

EXAMPLES:
    $0                  # Discover resources (dry-run, no files written)
    $0 --real-run       # Discover and write terraform files
    $0 --verbose        # Show detailed output
    $0 --real-run -v    # Write files with verbose output
EOF
}

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_verbose() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${BLUE}[VERBOSE]${NC} $1" >&2
    fi
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --real-run)
                DRY_RUN=false
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -r|--region)
                REGION="$2"
                shift 2
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
}

# Check AWS CLI availability
check_aws_cli() {
    if ! command -v aws &> /dev/null; then
        log_error "AWS CLI is required but not installed"
        exit 1
    fi

    if ! aws sts get-caller-identity &> /dev/null; then
        log_error "AWS CLI is not configured or lacks permissions"
        exit 1
    fi

    local caller_identity
    caller_identity=$(aws sts get-caller-identity --output json)
    local account_id
    account_id=$(echo "$caller_identity" | jq -r '.Account')
    local user_arn
    user_arn=$(echo "$caller_identity" | jq -r '.Arn')
    
    log_info "Connected to AWS account: $account_id"
    log_verbose "Using identity: $user_arn"
}

# Initialize output files
init_output_files() {
    if [[ "$DRY_RUN" == "false" ]]; then
        mkdir -p "$OUTPUT_DIR"
        
        # Initialize tfvars file
        cat > "$TFVARS_FILE" << EOF
# Generated by discover-frontend-resources.sh
# $(date)

# Resource existence flags
EOF

        # Initialize import commands file
        cat > "$IMPORT_FILE" << EOF
#!/bin/bash
# Generated by discover-frontend-resources.sh
# $(date)

set -e

EOF
        chmod +x "$IMPORT_FILE"
    fi
}

# Discover S3 buckets
discover_s3_buckets() {
    log_info "Discovering S3 buckets matching pattern: $S3_PATTERN"
    
    local buckets
    buckets=$(aws s3api list-buckets --output json --region "$REGION" 2>/dev/null || echo '{"Buckets":[]}')
    
    local matching_buckets=()
    while IFS= read -r bucket_name; do
        if [[ -n "$bucket_name" && "$bucket_name" == ${PROJECT_NAME}-*-frontend ]]; then
            matching_buckets+=("$bucket_name")
            log_success "Found S3 bucket: $bucket_name"
            
            # Get bucket details
            local bucket_region
            bucket_region=$(aws s3api get-bucket-location --bucket "$bucket_name" --output text 2>/dev/null || echo "us-east-1")
            if [[ "$bucket_region" == "None" ]]; then
                bucket_region="us-east-1"
            fi
            
            log_verbose "  Region: $bucket_region"
            
            # Check if bucket has website configuration
            local website_config
            if website_config=$(aws s3api get-bucket-website --bucket "$bucket_name" 2>/dev/null); then
                log_verbose "  Website hosting: enabled"
                local index_document
                index_document=$(echo "$website_config" | jq -r '.IndexDocument.Suffix // "index.html"')
                log_verbose "  Index document: $index_document"
            else
                log_verbose "  Website hosting: disabled"
            fi
            
            # Add to tfvars
            if [[ "$DRY_RUN" == "false" ]]; then
                local env_name
                if [[ "$bucket_name" == *"-staging-"* ]]; then
                    env_name="staging"
                elif [[ "$bucket_name" == *"-prod-"* ]] || [[ "$bucket_name" == *"-production-"* ]]; then
                    env_name="production"
                else
                    env_name="unknown"
                fi
                
                echo "s3_bucket_exists_${env_name} = true" >> "$TFVARS_FILE"
                echo "s3_bucket_name_${env_name} = \"$bucket_name\"" >> "$TFVARS_FILE"
                
                # Add import command
                echo "# Import S3 bucket: $bucket_name" >> "$IMPORT_FILE"
                echo "terraform import aws_s3_bucket.frontend_${env_name} $bucket_name" >> "$IMPORT_FILE"
                echo "" >> "$IMPORT_FILE"
            fi
        fi
    done < <(echo "$buckets" | jq -r '.Buckets[].Name // empty')
    
    if [[ ${#matching_buckets[@]} -eq 0 ]]; then
        log_warning "No S3 buckets found matching pattern: $S3_PATTERN"
    fi
    
    echo "${matching_buckets[@]}"
}

# Discover CloudFront distributions
discover_cloudfront_distributions() {
    log_info "Discovering CloudFront distributions"
    
    local distributions
    distributions=$(aws cloudfront list-distributions --output json 2>/dev/null || echo '{"DistributionList":{"Items":[]}}')
    
    local found_distributions=()
    local s3_buckets=("$@")
    
    while IFS= read -r distribution; do
        if [[ -z "$distribution" ]]; then continue; fi
        
        local dist_id
        dist_id=$(echo "$distribution" | jq -r '.Id')
        local domain_name
        domain_name=$(echo "$distribution" | jq -r '.DomainName')
        local status
        status=$(echo "$distribution" | jq -r '.Status')
        local enabled
        enabled=$(echo "$distribution" | jq -r '.Enabled')
        
        # Check if distribution points to our S3 buckets or domains
        local origins
        origins=$(echo "$distribution" | jq -r '.Origins.Items[]?.DomainName // empty')
        local aliases
        aliases=$(echo "$distribution" | jq -r '.Aliases.Items[]? // empty')
        
        local is_relevant=false
        
        # Check if origin points to our S3 buckets
        for origin in $origins; do
            for bucket in "${s3_buckets[@]}"; do
                if [[ -n "$bucket" && "$origin" == *"$bucket"* ]]; then
                    is_relevant=true
                    break 2
                fi
            done
        done
        
        # Check if aliases match our domains
        for alias in $aliases; do
            for domain in "${DOMAINS[@]}"; do
                if [[ "$alias" == "$domain" ]]; then
                    is_relevant=true
                    break 2
                fi
            done
        done
        
        if [[ "$is_relevant" == "true" ]]; then
            found_distributions+=("$dist_id")
            log_success "Found CloudFront distribution: $dist_id"
            log_verbose "  Domain: $domain_name"
            log_verbose "  Status: $status"
            log_verbose "  Enabled: $enabled"
            log_verbose "  Origins: $(echo "$origins" | tr '\n' ' ')"
            log_verbose "  Aliases: $(echo "$aliases" | tr '\n' ' ')"
            
            # Determine environment
            local env_name="unknown"
            for alias in $aliases; do
                if [[ "$alias" == "staging."* ]]; then
                    env_name="staging"
                    break
                elif [[ "$alias" == "storywriter.net" ]]; then
                    env_name="production"
                    break
                fi
            done
            
            if [[ "$DRY_RUN" == "false" ]]; then
                echo "cloudfront_distribution_exists_${env_name} = true" >> "$TFVARS_FILE"
                echo "cloudfront_distribution_id_${env_name} = \"$dist_id\"" >> "$TFVARS_FILE"
                
                # Add import command
                echo "# Import CloudFront distribution: $dist_id" >> "$IMPORT_FILE"
                echo "terraform import aws_cloudfront_distribution.frontend_${env_name} $dist_id" >> "$IMPORT_FILE"
                echo "" >> "$IMPORT_FILE"
            fi
        fi
    done < <(echo "$distributions" | jq -c '.DistributionList.Items[]? // empty')
    
    if [[ ${#found_distributions[@]} -eq 0 ]]; then
        log_warning "No relevant CloudFront distributions found"
    fi
    
    echo "${found_distributions[@]}"
}

# Discover Route53 records
discover_route53_records() {
    log_info "Discovering Route53 records for domains: ${DOMAINS[*]}"
    
    local hosted_zones
    hosted_zones=$(aws route53 list-hosted-zones --output json 2>/dev/null || echo '{"HostedZones":[]}')
    
    for domain in "${DOMAINS[@]}"; do
        local zone_name="${domain#*.}" # Remove subdomain if present
        if [[ "$domain" != *"."* ]]; then
            zone_name="$domain"
        fi
        
        # Find hosted zone
        local zone_id
        zone_id=$(echo "$hosted_zones" | jq -r --arg zone "$zone_name." '.HostedZones[] | select(.Name == $zone) | .Id' | sed 's|/hostedzone/||')
        
        if [[ -n "$zone_id" ]]; then
            log_success "Found hosted zone for $zone_name: $zone_id"
            
            # Get records for this domain
            local records
            records=$(aws route53 list-resource-record-sets --hosted-zone-id "$zone_id" --output json 2>/dev/null || echo '{"ResourceRecordSets":[]}')
            
            local record_exists=false
            while IFS= read -r record; do
                if [[ -z "$record" ]]; then continue; fi
                
                local record_name
                record_name=$(echo "$record" | jq -r '.Name' | sed 's/\.$//')
                local record_type
                record_type=$(echo "$record" | jq -r '.Type')
                
                if [[ "$record_name" == "$domain" ]]; then
                    record_exists=true
                    log_success "Found Route53 record: $domain ($record_type)"
                    
                    local record_value=""
                    if [[ "$record_type" == "A" ]]; then
                        local alias_target
                        alias_target=$(echo "$record" | jq -r '.AliasTarget.DNSName // empty')
                        if [[ -n "$alias_target" ]]; then
                            record_value="$alias_target"
                            log_verbose "  Alias target: $alias_target"
                        fi
                    elif [[ "$record_type" == "CNAME" ]]; then
                        record_value=$(echo "$record" | jq -r '.ResourceRecords[0].Value // empty')
                        log_verbose "  CNAME target: $record_value"
                    fi
                    
                    # Determine environment
                    local env_name="production"
                    if [[ "$domain" == "staging."* ]]; then
                        env_name="staging"
                    fi
                    
                    if [[ "$DRY_RUN" == "false" ]]; then
                        echo "route53_record_exists_${env_name} = true" >> "$TFVARS_FILE"
                        echo "route53_hosted_zone_id = \"$zone_id\"" >> "$TFVARS_FILE"
                        
                        # Add import command
                        echo "# Import Route53 record: $domain" >> "$IMPORT_FILE"
                        echo "terraform import aws_route53_record.frontend_${env_name} ${zone_id}_${domain}_${record_type}" >> "$IMPORT_FILE"
                        echo "" >> "$IMPORT_FILE"
                    fi
                fi
            done < <(echo "$records" | jq -c '.ResourceRecordSets[]? // empty')
            
            if [[ "$record_exists" == "false" ]]; then
                log_warning "No Route53 record found for domain: $domain"
            fi
        else
            log_warning "No hosted zone found for domain: $zone_name"
        fi
    done
}

# Discover ACM certificates
discover_acm_certificates() {
    log_info "Discovering ACM certificates for *.storywriter.net"
    
    local certificates
    certificates=$(aws acm list-certificates --region "$REGION" --output json 2>/dev/null || echo '{"CertificateSummaryList":[]}')
    
    local found_certificates=()
    
    while IFS= read -r cert_arn; do
        if [[ -z "$cert_arn" ]]; then continue; fi
        
        local cert_details
        cert_details=$(aws acm describe-certificate --certificate-arn "$cert_arn" --region "$REGION" --output json 2>/dev/null || echo '{}')
        
        local domain_name
        domain_name=$(echo "$cert_details" | jq -r '.Certificate.DomainName // empty')
        local subject_alternative_names
        subject_alternative_names=$(echo "$cert_details" | jq -r '.Certificate.SubjectAlternativeNames[]? // empty' | tr '\n' ' ')
        local status
        status=$(echo "$cert_details" | jq -r '.Certificate.Status // empty')
        
        # Check if certificate covers our domains
        local covers_storywriter=false
        if [[ "$domain_name" == "*.storywriter.net" || "$domain_name" == "storywriter.net" ]]; then
            covers_storywriter=true
        fi
        
        for san in $subject_alternative_names; do
            if [[ "$san" == "*.storywriter.net" || "$san" == "storywriter.net" ]]; then
                covers_storywriter=true
                break
            fi
        done
        
        if [[ "$covers_storywriter" == "true" ]]; then
            found_certificates+=("$cert_arn")
            log_success "Found ACM certificate: $cert_arn"
            log_verbose "  Domain: $domain_name"
            log_verbose "  Status: $status"
            log_verbose "  SANs: $subject_alternative_names"
            
            if [[ "$DRY_RUN" == "false" ]]; then
                echo "acm_certificate_exists = true" >> "$TFVARS_FILE"
                echo "acm_certificate_arn = \"$cert_arn\"" >> "$TFVARS_FILE"
                
                # Add import command
                echo "# Import ACM certificate: $cert_arn" >> "$IMPORT_FILE"
                echo "terraform import aws_acm_certificate.frontend $cert_arn" >> "$IMPORT_FILE"
                echo "" >> "$IMPORT_FILE"
            fi
        fi
    done < <(echo "$certificates" | jq -r '.CertificateSummaryList[]?.CertificateArn // empty')
    
    if [[ ${#found_certificates[@]} -eq 0 ]]; then
        log_warning "No ACM certificates found for *.storywriter.net"
    fi
    
    echo "${found_certificates[@]}"
}

# Discover IAM policies
discover_iam_policies() {
    log_info "Discovering IAM policies related to frontend deployment"
    
    local policies
    policies=$(aws iam list-policies --scope Local --output json 2>/dev/null || echo '{"Policies":[]}')
    
    local found_policies=()
    local search_terms=("storywriter" "frontend" "s3-frontend" "cloudfront-frontend")
    
    while IFS= read -r policy; do
        if [[ -z "$policy" ]]; then continue; fi
        
        local policy_name
        policy_name=$(echo "$policy" | jq -r '.PolicyName')
        local policy_arn
        policy_arn=$(echo "$policy" | jq -r '.Arn')
        
        # Check if policy name contains relevant terms
        local is_relevant=false
        for term in "${search_terms[@]}"; do
            if [[ "$policy_name" == *"$term"* ]]; then
                is_relevant=true
                break
            fi
        done
        
        if [[ "$is_relevant" == "true" ]]; then
            found_policies+=("$policy_arn")
            log_success "Found IAM policy: $policy_name"
            log_verbose "  ARN: $policy_arn"
            
            # Get policy document to check for S3/CloudFront permissions
            local policy_version
            policy_version=$(echo "$policy" | jq -r '.DefaultVersionId')
            local policy_document
            policy_document=$(aws iam get-policy-version --policy-arn "$policy_arn" --version-id "$policy_version" --output json 2>/dev/null || echo '{}')
            
            local actions
            actions=$(echo "$policy_document" | jq -r '.PolicyVersion.Document.Statement[]?.Action[]? // empty' 2>/dev/null | sort -u | tr '\n' ' ')
            if [[ -n "$actions" ]]; then
                log_verbose "  Actions: $actions"
            fi
            
            if [[ "$DRY_RUN" == "false" ]]; then
                echo "# IAM policy found: $policy_name" >> "$TFVARS_FILE"
                echo "iam_policy_exists_$(echo "$policy_name" | tr '[:upper:]' '[:lower:]' | tr '-' '_') = true" >> "$TFVARS_FILE"
                
                # Add import command
                echo "# Import IAM policy: $policy_name" >> "$IMPORT_FILE"
                echo "terraform import aws_iam_policy.frontend_$(echo "$policy_name" | tr '[:upper:]' '[:lower:]' | tr '-' '_') $policy_arn" >> "$IMPORT_FILE"
                echo "" >> "$IMPORT_FILE"
            fi
        fi
    done < <(echo "$policies" | jq -c '.Policies[]? // empty')
    
    if [[ ${#found_policies[@]} -eq 0 ]]; then
        log_warning "No relevant IAM policies found"
    fi
    
    echo "${found_policies[@]}"
}

# Validate resource relationships
validate_relationships() {
    local s3_buckets=($1)
    local cloudfront_distributions=($2)
    
    log_info "Validating resource relationships"
    
    # Check for orphaned CloudFront distributions
    for dist_id in "${cloudfront_distributions[@]}"; do
        if [[ -z "$dist_id" ]]; then continue; fi
        
        local distribution
        distribution=$(aws cloudfront get-distribution --id "$dist_id" --output json 2>/dev/null || echo '{}')
        
        local origins
        origins=$(echo "$distribution" | jq -r '.Distribution.DistributionConfig.Origins.Items[]?.DomainName // empty')
        
        local has_s3_origin=false
        for origin in $origins; do
            for bucket in "${s3_buckets[@]}"; do
                if [[ -n "$bucket" && "$origin" == *"$bucket"* ]]; then
                    has_s3_origin=true
                    break 2
                fi
            done
        done
        
        if [[ "$has_s3_origin" == "false" ]]; then
            log_warning "CloudFront distribution $dist_id has no matching S3 bucket origin"
            log_verbose "  Origins: $(echo "$origins" | tr '\n' ' ')"
        else
            log_success "CloudFront distribution $dist_id has valid S3 origin"
        fi
    done
    
    # Check for orphaned S3 buckets
    for bucket in "${s3_buckets[@]}"; do
        if [[ -z "$bucket" ]]; then continue; fi
        
        local has_cloudfront=false
        for dist_id in "${cloudfront_distributions[@]}"; do
            if [[ -z "$dist_id" ]]; then continue; fi
            
            local distribution
            distribution=$(aws cloudfront get-distribution --id "$dist_id" --output json 2>/dev/null || echo '{}')
            
            local origins
            origins=$(echo "$distribution" | jq -r '.Distribution.DistributionConfig.Origins.Items[]?.DomainName // empty')
            
            for origin in $origins; do
                if [[ "$origin" == *"$bucket"* ]]; then
                    has_cloudfront=true
                    break 2
                fi
            done
        done
        
        if [[ "$has_cloudfront" == "false" ]]; then
            log_warning "S3 bucket $bucket has no associated CloudFront distribution"
        else
            log_success "S3 bucket $bucket has associated CloudFront distribution"
        fi
    done
}

# Generate summary report
generate_summary() {
    local s3_buckets=($1)
    local cloudfront_distributions=($2)
    local acm_certificates=($3)
    local iam_policies=($4)
    
    log_info "Discovery Summary:"
    echo "=========================================="
    echo "S3 Buckets Found: ${#s3_buckets[@]}"
    for bucket in "${s3_buckets[@]}"; do
        echo "  - $bucket"
    done
    
    echo ""
    echo "CloudFront Distributions Found: ${#cloudfront_distributions[@]}"
    for dist in "${cloudfront_distributions[@]}"; do
        echo "  - $dist"
    done
    
    echo ""
    echo "ACM Certificates Found: ${#acm_certificates[@]}"
    for cert in "${acm_certificates[@]}"; do
        echo "  - $cert"
    done
    
    echo ""
    echo "IAM Policies Found: ${#iam_policies[@]}"
    for policy in "${iam_policies[@]}"; do
        echo "  - $policy"
    done
    
    echo ""
    echo "Route53 Records: Checked for ${DOMAINS[*]}"
    
    if [[ "$DRY_RUN" == "false" ]]; then
        echo ""
        echo "Generated Files:"
        echo "  - Terraform vars: $TFVARS_FILE"
        echo "  - Import commands: $IMPORT_FILE"
    else
        echo ""
        echo "DRY RUN MODE - No files written"
        echo "To write files, run with: $0 --real-run"
    fi
    echo "=========================================="
}

# Main execution function
main() {
    parse_args "$@"
    
    log_info "Starting AWS frontend resource discovery"
    log_info "Project: $PROJECT_NAME"
    log_info "Region: $REGION"
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Mode: DRY RUN (no files will be written)"
    else
        log_info "Mode: REAL RUN (files will be written)"
    fi
    
    check_aws_cli
    init_output_files
    
    # Discover resources
    local s3_buckets
    s3_buckets=($(discover_s3_buckets))
    
    local cloudfront_distributions
    cloudfront_distributions=($(discover_cloudfront_distributions "${s3_buckets[@]}"))
    
    discover_route53_records
    
    local acm_certificates
    acm_certificates=($(discover_acm_certificates))
    
    local iam_policies
    iam_policies=($(discover_iam_policies))
    
    # Validate relationships
    validate_relationships "${s3_buckets[*]}" "${cloudfront_distributions[*]}"
    
    # Finalize output files
    if [[ "$DRY_RUN" == "false" ]]; then
        echo "" >> "$TFVARS_FILE"
        echo "# Discovery completed: $(date)" >> "$TFVARS_FILE"
        
        echo "" >> "$IMPORT_FILE"
        echo "echo \"Import commands completed\"" >> "$IMPORT_FILE"
    fi
    
    # Generate summary
    generate_summary "${s3_buckets[*]}" "${cloudfront_distributions[*]}" "${acm_certificates[*]}" "${iam_policies[*]}"
    
    log_success "Frontend resource discovery completed"
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi